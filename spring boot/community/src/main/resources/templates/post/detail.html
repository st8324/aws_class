<!DOCTYPE html>
<html 
	xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" 
	layout:decorate="~{layout/layout.html}">
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body >
	<main layout:fragment="content" class="container">
		<h1>게시글 상세</h1>
		<div th:if="${post != null}">
			<div class="mb-3">
				<label>제목 : </label>
				<div th:text="${post.po_title}" class="form-control"></div>
			</div>
			<div class="input-group mb-3">
				<div class="form-control" th:text="'작성자 : ' + ${post.po_me_id}"></div>
				<div class="form-control" th:text="'조회수 : ' + ${post.po_view}"></div>
			</div>
			<!-- 추천/비추천 버튼 그룹 -->
			<div class="mb-3 d-flex justify-content-center">
				<button 
					class="btn btn-up btn-outline-success me-3"
					th:onclick="|setLike(${post.po_num}, 1)|">추천</button>
				<button 
					class="btn btn-down btn-outline-danger"
					th:onclick="|setLike(${post.po_num}, -1)|">비추천</button>
			</div>
			<div class="mb-3">
				<label>내용 : </label>
				<div class="form-control" style="min-height: 400px;"
					th:text="${post.po_content}"></div>
			</div>
			<div class="mb-3" th:if="${!files.isEmpty()}">
				<label>첨부파일([[${files.size()}]])</label>
				<a th:each="file : ${files}"
					th:href="@{|/download/${file.fi_name}|}"
					th:text="${file.fi_ori_name}"
					class="form-control mb-3"
					th:download="${file.fi_ori_name}"
				></a>
			</div>
			
			
			<!-- 삭제버튼 추가 : 게시글 작성자만 삭제버튼이 보임 -->
			<form 
				th:if="${#authentication.name == post.po_me_id}"
				th:action="@{/post/delete/{num}(num=${post.po_num})}"
				method="post">
				<button class="btn btn-outline-danger">삭제</button>
				<a th:href="@{/post/update/{num}(num=${post.po_num})}"
				   class="btn btn-outline-warning">수정</a>
			</form>
			
			<hr>
			<h1>댓글</h1>
			<!-- 댓글 영역-->
			<div class="comment-container">
				<!-- 댓글 목록 영역 -->
				<div class="comment-list">
					<div class="comment-item mb-3 form-control">
						<div class="d-flex justify-content-between">
							<div>작성자</div>
							<div>2026.01.09. 17:10</div>
						</div>
						<hr>
						<div class="mt-3">댓글 내용</div>
					</div>
					<div class="comment-item mb-3 form-control">
						<div class="d-flex justify-content-between">
							<div>작성자</div>
							<div>2026.01.09. 17:10</div>
						</div>
						<hr>
						<div class="mt-3">댓글 내용</div>
						<div class="mt-3">
							<button class="btn-mod btn btn-outline-warning">수정</button>
							<button class="btn-del btn btn-outline-danger">삭제</button>
						</div>
					</div>
				</div>
				
				<!-- 댓글 페이지네이션 영역 -->
				<div class="comment-pagination">
					<ul class="pagination justify-content-center">
					    <li class="page-item"><a class="page-link" href="javascript:void(0);">Previous</a></li>
					    <li class="page-item"><a class="page-link" href="javascript:void(0);">1</a></li>
					    <li class="page-item"><a class="page-link" href="javascript:void(0);">2</a></li>
					    <li class="page-item"><a class="page-link" href="javascript:void(0);">Next</a></li>
				  	</ul>
				</div>
				
				<!-- 댓글 입력 영역 -->
				<div class="comment-input">
					<form class="input-group" 
						onsubmit="insertComment(event, this)">
						<textarea class="form-control" 
							onfocus="checkLogin(this)"></textarea>
						<button class="btn btn-outline-success">등록</button>
					</form>
				</div>
			</div>
		</div>
		<div th:if="${post == null}">
			<h1>삭제되거나 등록되지 않은 게시글입니다.</h1>
		</div>
		<!-- 전역으로 사용하는 변수 모음 -->
		<script type="text/javascript">
		//추천버튼
		const upBtn = document.querySelector(".btn-up");
		//비추천버튼
		const downBtn = document.querySelector(".btn-down");
		//로그인한 아이디값 가져오기
		const id = '[[${user}]]';
		//게시글 번호. CommentDTO의 게시글 번호 필드와 이름이 같게 작성
		const postNum = [[${post.po_num}]];
		//댓글 목록을 보여줄 요소
		const listContainer = document.querySelector(".comment-list");
		//댓글 페이지 정보를 관리하는 객체
		const cri = {
			page : 1, //현재 페이지 정보
			postNum //게시글 번호
		}
		//페이지네이션을 보여줄 요소
		const commentPagination = 
			document.querySelector(".comment-pagination .pagination");
		
		</script>
		
		
		<!-- 추천, 비추천 js -->
		<script type="text/javascript">
		
		
		//게시글 번호, 추천상태를 이용하여 추천결과를 알려주는 함수
		async function setLike(postNum, state) {
			const postData = {
				// 보낼 데이터 채우기
				// postNum : postNum 한거와 같음
				// 왼쪽 이름을 postNum으로 하고 값은 postNum변수에 있는 값을 가져옴
				postNum, //게시글 번호
				state //추천 상태
			};

			try {
				const response = 
					//fetch는 지정된 URL로 비동기 통신요청하는 함수
					//결과를 Promise객체로 반환
					await fetch('/post/like',
					//설정
					{
						//전송방식을 post로
						method : 'POST',
						//Content-type : 전송할 데이터 타입.
						//   json으로 전송하는 경우 반드시 작성.
						headers : {
							//전송할 데이터가 json타입이다라고 지정
							'Content-Type' : 'application/json',
						},
						//보낼 데이터
						body : JSON.stringify(postData)
					});

				// 1. HTTP 응답 상태가 성공인지 확인
				if (response.ok) {
					// 서버가 단순 텍스트를 주면 text(), JSON을 주면 json()
					// 서버가 보낸 결과를 text() : 텍스트로 가져옴
					// 서버가 보낸 결과를 json() : json 객체로 가져옴
					const result = await response.text();
					alert(result);
					loadLikeBtns();
					
				} else {
					// 2. 400, 500 에러 등에 대한 처리
					const errorText = await response.text();
					console.log("서버 오류: " + errorText);
				}

			} catch (error) {
				// 3. 네트워크 단절이나 문법 에러 등 아주 예외적인 상황
				console.error("통신 중 오류 발생:", error);
				alert("통신에 실패했습니다.");
			}
		}
		//추천/비추천 수를 불러와서 버튼에 적용하는 함수
		async function loadLikeBtns(){
			const postNum = [[${post.po_num}]];
			//게시글 번호를 서버에 보내고, 추천수와 비추천수를 가져와서 버튼에 적용
			
			try{
				//url에 게시글 번호를 전달
				const response = await fetch('/post/like/count/'+postNum);
				if(response.ok){
					//서버에서 보낸 추천, 비추천수 가져옴
					const result = await response.json();
					
					const up = result.up;
					const down = result.down;
					//버튼에 적용
					
					//추천 버튼 텍스트 수정
					upBtn.innerText = `추천(${up})`;
					//비추천 버튼 텍스트 수정
					downBtn.innerText = `비추천(${down})`;
					checkLike();
					
				}else{
					console.log("추천/비추천 수 가져오기 실패");
				}
				
			}catch(error){
				console.error("예외 발생");
			}
		}
		
		//로그인한 사용자의 게시글 추천/비추천여부에 따라 추천/비추천 버튼 색상 변경
		async function checkLike(){
			const postNum = [[${post.po_num}]];
			
			try{
				const response = await fetch('/post/like/check/'+postNum);
				
				if(response.ok){
					const result = await response.text();
					
					//로그인하지 않았거나 추천/비추천을 안했으면
					if(result == 0){
						return;
					}
					//로그인한 사용자가 추천/비추천을 했으면 알맞은 버튼 색상을 변경 
					//1. 기본 버튼으로 설정
					upBtn.classList.remove('btn-success');
					upBtn.classList.remove('btn-outline-success');
					
					downBtn.classList.remove('btn-danger');
					downBtn.classList.remove('btn-outline-danger');
					
					//2. 상태에 맞게 버튼 색상을 지정
					upBtn.classList.add
						(`btn-${result == 1 ? '' : 'outline-'}success`);
					downBtn.classList.add
						(`btn-${result == -1 ? '' : 'outline-'}danger`);
				}else{
					console.log("불러오기 실패");
				}
			}catch(error){
				console.error(error);
			}
		}
		
		</script>
		
		<!-- 댓글 js -->
		<script type="text/javascript">
			//로그인 되었는지 확인
			function checkLogin(element){
				
				//로그인이 안되어 있으면(빈문자열이면)
				if(!id){
					//포커스 해제
					element.blur();
					//로그인페이지로 이동할건지를 물어봄
					let res = confirm("로그인이 필요한 서비스입니다.\n로그인 페이지로 이동하겠습니까?");
					if(res){
						location.href="/login";
					}
				}
			}
			
			function insertComment(event,  el, coNum){
				event.preventDefault();
				//댓글 등록일 때 coNum을 안넣어줌
				//대댓글 등록일 때 coNum을 넣어줌
				//댓글이면
				if(!coNum){
					coNum = 0;
				}
				//댓글 내용을 가져옴
				//댓글 입력창 요소를 선택
				const commentInsertInputEl = 
					el.querySelector("textarea");
				const content = commentInsertInputEl.value;
				
				//댓글이 비어 있으면 알림 처리
				if(!content.trim()){
					alert("댓글 내용을 입력하세요.");
					return;
				}
				let comment = {
					content, //댓글내용. CommentDTO에서 내용을 content로 설정함
					postNum,//게시글 번호
					coOriNum : coNum
				}
				//비동기통신으로 댓글 내용을 전송 
				sendInsertComment(comment);
				//추가한 댓글 내용 삭제
				commentInsertInputEl.value = '';
				
			}
			async function sendInsertComment(comment){
				try{
					//await는 비동기인 fetch가 다 끝날때까지 기다리게 하는 역할
					//그래야 밑에서 response를 이용할 때 문제가 안 생김
					const response = await fetch('/comment/insert', {
						method : 'post',
						headers : {
							'Content-Type' : 'application/json' //보내는 데이터 형태
						},
						body : JSON.stringify(comment) //보낼 데이터
					});
					//서버에서 댓글 추가 결과를 문자열로 보낼 예정
					const result = await response.text();
					//알림창으로 댓글 추가 결과를 알려줌
					alert(result);
					
					//댓글 목록 다시 불러오기
					cri.page = 1;
					getCommentList(cri);
					
				}catch(error){
					console.error("예외 발생");
					console.error(error);
				}
			}
			//댓글 불러오는 함수
			async function getCommentList(cri){
				try{
					//서버에 댓글 목록 가져오라고 요청
					const response = await fetch(
						`/comment/list`, {
						//옵션은 페이지네이션 적용할 때 추가
						method : 'post',
						headers : {
							'Content-Type' : 'application/json' 
						},
						body : JSON.stringify(cri)
					});
					
					//가져와서 화면에 출력
					//서버에서 보낸 댓글 목록을 가져옴
					const result = await response.json();
					
					//가져온 댓글 목록을 이용하여 화면을 구성
					drawCommentList(result.list);
					//가져온 페이지네이션 정보를 이용하여 페이지네이션을 구성
					drawCommentPagination(result.pm);
				}catch(error){
					console.log("예외 발생");
					console.log(error);
				}
			}
			//댓글을 화면에 배치하는 함수
			function drawCommentList(list){
				//댓글 목록이 없으면
				if(list.length == 0){
					listContainer.innerHTML = `
					<div class="form-control">등록된 댓글이 없습니다.<div>
					`;
					return;
				}
				//댓글 목록이 있으면
				//for of는 향상된 for문
				//for in은 key값을 가져와서 활용
				let items = '';
				for(comment of list ){
					//댓글이 삭제된 경우
					if(comment.co_del == 'Y'){
						items += `
							<div class="comment-item mb-3 form-control">
								작성자에 의해 삭제된 댓글입니다.
							</div>
						`;
						continue;//16:1 Uncaught ReferenceError: changeBox is not defined
					}
					//대댓글 버튼
					let replyBtn = `
						<button class="btn-reply btn btn-outline-dark" 
							onclick="changeReplyBox(${comment.co_num}, this)">대댓글</button>
					`
					//수정/삭제 버튼
					let btns = `
					<button class="btn-mod btn btn-outline-warning" 
						onclick="changeBox(${comment.co_num}, this)">수정</button>
					<button class="btn-del btn btn-outline-danger" 
						onclick="deleteComment(${comment.co_num})">삭제</button>
					`;
					//댓글 전체
					items += `
					<div class="${comment.co_num != comment.co_ori_num ? 'ps-5' : ''}">
						<div class="comment-item mb-3 form-control">
							<div class="d-flex justify-content-between">
								<div>${comment.co_me_id}</div>
								<div>${comment.co_date}</div>
							</div>
							<hr>
							<pre class="mt-3">${comment.co_content}</pre>
							<div class="mt-3">
								${comment.co_me_id == '[[${user}]]' ? btns : ''}
								${comment.co_num == comment.co_ori_num ? replyBtn : ''}
							</div>
						</div>
					</div>
					`;
				}
				listContainer.innerHTML = items;
			}
			
			function drawCommentPagination(pm){
				let pagination = '';
				
				//pm을 이용하여 페이지네이션을 구성
				//이전 버튼 활성화
				if(pm.prev){
					pagination += `
					<li onclick="changePage(${pm.startPage - 1})"
						class="page-item">
						<a class="page-link" href="javascript:void(0);">이전</a>
					</li>
					`
				}
				
				for(i = pm.startPage; i<= pm.endPage; i++){

					pagination += `
					<li onclick="changePage(${i})"
						class="page-item ${pm.cri.page == i ? 'active' : ''}">
				    	<a class="page-link" href="javascript:void(0);">${i}</a>
				    </li>
					`;
				}
				
				if(pm.next){
					pagination += `
					<li onclick="changePage(${pm.endPage + 1})"
						class="page-item">
				    	<a class="page-link" href="javascript:void(0);">다음</a>
				    </li>
					`
				}
				
				commentPagination.innerHTML = pagination;
			}
			
			function changePage(page){
				cri.page = page;
				getCommentList(cri);
			}
			
			async function deleteComment(coNum){
				
				try{
					//서버로 댓글 번호를 전송
					const response = await fetch(
						`/comment/delete/${coNum}`, {
						//보내는 방식
						method : 'post',
						headers : {
							//보낼 데이터의 종류
							//'Content-Type' : ''
						},
						//보낼 데이터
						//body : ''
					});
					
					//서버에서 보낸 문자열을 alert로 출력
					if(response.ok){
						const result = await response.text();
						alert(result);
						//댓글 목록 새로고침
						getCommentList(cri);
					}
					
				}catch(error){
					console.error("예외 발생");
					console.error(error);
				}
			}
			/**
			num : 댓글 번호, el : 수정버튼
			el은 수정창을 배치할 때 사용할 예정
			*/
			function changeBox(num, el){
				initBox(el);
				
				//댓글 하나를 감싸는 박스
				const item = el.closest(".comment-item");
				//댓글에 댓글 내용이 있는 pre태그
				const pre = item.querySelector('pre');
				//댓글 내용 가져옴
				const content = pre.textContent;
				
				let inputBox = `
				<div class="comment-update-box">
					<form class="input-group" 
						onsubmit="updateComment(event, this, ${num})">
						<textarea class="form-control" 
							onfocus="checkLogin(this)">${content}</textarea>
						<button class="btn btn-outline-success">수정</button>
					</form>
				</div>	
				`;
				//수정/삭제 버튼 박스
				const parent = el.parentElement;
				
				//댓글 내용있는 박스
				const contentBox = parent.previousElementSibling;
				
				//수정, 삭제버튼 안보이게
				parent.classList.add('d-none');
				
				//기존 댓글 내용 안보이게
				contentBox.classList.add('d-none');
				
				//댓글 내용 입력 창 박스 추가 
				parent.insertAdjacentHTML('beforeBegin',inputBox);
			}
			function updateComment(event, el, num){
				//form태그의 submit을 막음(서버로 전송하는걸 막음)
				event.preventDefault();
				//댓글 입력 요소
				const textareaEl = el.querySelector("textarea");
				//입력한 댓글 내용 
				const content = textareaEl.value;
				
				//댓글번호(num)와 댓글내용(content)을 가진 객체를 생성
				const comment = {
					coNum : num,
					content //content : content
				};
				
				// 댓글 수정
				sendUpdateComment(comment);
					
			}
			async function sendUpdateComment(comment){
				try{
					//서버로 수정할 정보를 전송
					const response = await fetch('/comment/update', {
						method : 'post',
						headers : {
							'Content-Type' : 'application/json'
						},
						body : JSON.stringify(comment)
					});
					if(response.ok){
						//서버에서 보낸 값을 문자열로 받아옴
						const result = await response.text();
						//받아온 문자열을 alert로 출력
						alert(result);
						//댓글 목록 새로고침
						getCommentList(cri);
					}
				}catch(error){
					console.error(error);
				}
			}
			function changeReplyBox(coNum, el){
				//기존에 수정클릭 또는 대댓글 클릭한 상태를 초기화 시키는 함수
				initBox(el);
				const parent = el.parentElement;
				
				let container = `
				<div class="comment-reply-input mt-3">
					<form class="input-group" 
						onsubmit="insertComment(event, this, ${coNum})">
						<textarea class="form-control" 
							onfocus="checkLogin(this)"></textarea>
						<button class="btn btn-outline-success">등록</button>
					</form>
				</div>
				`
				parent.insertAdjacentHTML('afterend',container);
			}
			function initBox(el){
				//댓글 하나 전체를 감싸는 박스
				const item = el.closest(".comment-item");
				
				//댓글 수정 버튼 클릭 시 추가되는 form태그가 있는 박스
				const updateBox = item.querySelector('.comment-update-box');
				
				if(updateBox){
					updateBox.remove();
				}
				//열려있는 대댓 추가창이 있으면 닫음
				const replyBox = item.querySelector('.comment-reply-input');
				if(replyBox){
					replyBox.remove();
				}
				
			}
		</script>
		<!-- 화면이 처음 로딩될때 호출되는 함수 정리 -->
		<script type="text/javascript">
			//댓글 불러오도록 호출
			getCommentList(cri);
			//추천/비추천 버튼 불러오기
			loadLikeBtns();
		</script>
	</main>
</body>
</html>







